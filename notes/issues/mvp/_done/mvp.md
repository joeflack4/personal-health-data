# Personal health data analysis: MVP
We're going to set up a new repository. There will be a lot of different stuff for you to do.

The basic idea that we'll analyzing my health data that I've been tracking in a Google Form. The data gets populated 
into a Google Sheet.

The health form tracks different things, such as alcohol use, sleep, gaming habits, panic attacks, and more. For the 
MVP, we're just going to focus on alcohol use. And we're going to just track the total number of drinks drank that week.
We'll organize that data, and then we'll plot it in an interactive line graph using Python Dash, and deploy it to 
Render.com.

## Directory structure
```
.
├── app/  # backend and frontend can go here. This will house the Python dash app
├── env/  # .gitignore'd environment variables stored in env/.env
├── lib/  # This will contain the code that interacts with the Google Sheet data source, parses it, does data transformations, and outputs those transformations in whatever form is needed, either as a function returning a pandas DF, writing to a sqlite database, or whatever works for the implementation. 
├── notes/  # Markdown files containing notes, specs, tasks lists, etc.
```

## Notable files
- `/config.yaml`: Configuration variables committed to the repo. Give this a read before you start to populate the IG.
- `/env/.env`: Hidden vars. Feel free to ask the user to populate things here.
- Sqlite DB file in root of repo: It is .gitignore'd. Could contain transformations generated by `lib/` to be used by `app/`.

## Tasks overview
Your task right now is not to begin implementation, but to create implementation guides (IGs).  

Create the following .md files in `notes/`, corresponding to the sections and their details below.
- `mvp-1-setup.md`
- `mvp-2-lib.md`
- `mvp-3-app.md`

Basically, think about these details / requirements, and create these documents, and inside of the documents, create 1 
or more multi-phase task lists using markdown checkboxes, which describe in a granular and technical way the work that 
needs to be completed.

If you have any questions, you can also create a `questions.md`. In it, you would create separate subsections each with 
their own subheaders, with a title for the subsection, followed by a question, and room for an answer to be provided by 
the user. 

### 1. Set up
We want to use uv for package management. Also figure out any environment variables you need to get from the user, such 
as auth information to download the Google Sheet data (you may not need any such credentials, as I think that the sheet 
is public, or render.com credentials in the case that they have a CLI we can use. You can ask that in`questions.md`.

### 2. Lib
Commands will be run on this library to fetch, analyze, and transform data. Use the 'click' package. 

### Analyzing data
You should fetch data from the google sheet. From what I can tell, the URL follows this structure: 
https://docs.google.com/spreadsheets/d/SHEET_ID. You'll find the sheet-id var in config.yaml to use for this. If it's 
not there, then check the SHEET_ID var in .env.  

You should parse out the data and populate tables in a sqlite database that are in a format that the Dash app can 
easily read from and do little to no transformations before rendering visualizations. You may want or need some 
intermediary normalized tables as well; that is totally fine, as the Google Sheet data source is idiosyncratic and 
messy.

The main columns you'll need to focus on here are:
- Timestamp: Here's an example value showing the format. 1/30/2021 1:36:16
- A) Report event (今): Contains event label for an event that was reported to have happened with corresponding time shown in the "Timestamp" column. If null, then the event for this row will be found in the other column (別時).
- Is now the stop or start time?: This will only be populated when: (i) the event is an 今 (not a 別時) event, and (ii) if this is an event that is a timespan rather than a single point. Valid values are: 'Start' or 'Stop'. An event should always have a matching start and stop time. If there is no stop time, then it is an invalid event and should be discarded. If the stop time occurs more than 24 hours in the future, also consider it invalid and discard. If there is a stop time but no associated start time before it, discard. If the start time occurs between 00:00:00 (midnight) and the value shown in `next-day-cutoff-HH-mm-ss` (e.g. 00:08:00 for 8am) on `config.yaml`, then when reporting what day this took place, use the previous day. This is because I (the user) am a late sleeper, usually falling asleep around 2-3am, but even as late as 8am on rare occasion. So for example if I report an event at 3am on January 15th, it should be considered part of the continuous evening of January 14th, and so should be reported as a January 14th event.
- B) Report event (別時): Contains event label for an event that was reported to have happened with corresponding time shown in the "Retro: Time" and "Retro: Date" columns. If null, then the event for this row will be found in the other column (今).
- Retro: stop or start time?: This will only be populated when: (i) the event is an 別時 (not a 今) event, and (ii) if this is an event that is a timespan rather than a single point. Otherwise, all of the other information describing the "Is now the stop or start time?" column also applies to this column.
- Retro: Time: Populated for any 別時 rows. Example value: 1:00:00 AM
- Retro: Date: Populated for any 別時 rows. Example value: 1/31/2021
- Comments: Free text field. Sometimes there will be specific information in here that is important, and there will be text parsing rules, probably using regular expressions, to extract that data.

### MVP analysis: alcohol use
Your first analysis will be on alcohol use. 

Alcohol use events are reported by using the value "飲み物" ("drink") in the event columns. By default, for every such 
row, consider this 1 standard alcoholic beverage. However, you should also parse the 'Comments' field. Sometimes it 
contains information that may override this, typically when fractions of a drink are reported. Example values: 1.5, .5, 
0.5. So you'll want to use a regular expression to parse this field. It will probably be adequate to check for the 
comments field to start with a number or a period, and then some string of numbers, with either the end of the line 
ocurring, or otherwise whitespace. If whitespace, then you can ignore anything after that whitespace.

### Future DB updates
There should be a command to update the DB. When this is done, first back up the DB just in case anything goes wrong. 
Then, create an entirely new DB. If you get an error or failure, then restore the backed up DB. There should be a 
function that runs which does this, and one of the return params should be a list of error objects. If the CLI is run, 
then it should call this func and then print any of those errors that are returned.   

### 3. App
This will be a Python Dash app. You will want to read the data in the Sqlite DB, and display tables and interactive 
visualizations.

As mentioned, we'll start off by displaying a line graph of drinks per week. User should be able to also select a date 
sub-range. Ideally, this should also include a trend line.  

When the app loads, if the .sqlite DB is not present, it should create it. You should have some way of storing 
information in the DB as well regarding when it was last updated. And populate that with null in the event that you 
have created the DB but have never ran an update. This information should be displayed in the frontend. If there's no 
data yet (null), then show a message telling them that the db is being built and that they should check again in a few 
minutes. If there is data present, display the tables and visualizations. And also display somewhere the datetime that 
the DB was last updated. Then there should be a "Sync" button. When that is pressed, a process will run that updates the 
DB from the source data.
